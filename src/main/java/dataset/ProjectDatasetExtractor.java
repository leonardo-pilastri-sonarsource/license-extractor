package dataset;

import com.fasterxml.jackson.databind.ObjectMapper;
import dataset.toplibdef.Lib;
import dataset.toplibdef.Libs;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import org.springframework.boot.json.JacksonJsonParser;

// using top 1000 libraries according to:
// https://github.com/SonarSource/sonar-security/blob/master/config/src/main/resources/config/javasecurity-autogenerated/top-libs.def.json
public class ProjectDatasetExtractor {

  private static final TreeSet<LibraryUsage> LIBS_BY_USAGE = new TreeSet<>();
  private static final Set<String> DISCARDED_LICENSES = new TreeSet<>();
  public static final String MAVEN_HOME = System.getenv("MAVEN_HOME");
  private static List<Lib> notWorking = new ArrayList<>();

  record LibraryUsage(LocalArtifact artifact, int dependents, String license) implements Comparable<LibraryUsage> {
    @Override
    public int compareTo(LibraryUsage o) {
      return o.dependents - dependents;
    }
  }

  public static void main(String[] args) {
    assertNotEmpty(MAVEN_HOME, "MAVEN_HOME environment variable is not set.");
    var libs = getTopLibs();

    try (ExecutorService executor = Executors.newFixedThreadPool(8)) {
      for (Lib lib : libs) {
        executor.submit(() -> {
          var groupArtifact = lib.identifier().split(":");
          var artifact = new LocalArtifact(groupArtifact[0], groupArtifact[1], lib.version(),
            toLocalJarPath(groupArtifact[0], groupArtifact[1], lib.version()));
          if (downloadArtifact(artifact)) {
            String licenseFileContent = new JarLicense(artifact).getLicense();
            if (licenseFileContent != null) {
              if (Licenses.isForbidden(licenseFileContent)) {
                String license = licenseFileContent.substring(0, Math.min(100, licenseFileContent.length() - 1));
                var deps = DepsDevDependents.fetchDependents(artifact);
                if (deps != null) {
                  LIBS_BY_USAGE.add(new LibraryUsage(artifact, deps.dependentCount, license));
                }
              } else {
                DISCARDED_LICENSES.add(licenseFileContent);
              }
            } else {
              didNotWork(lib);
              System.out.println("No license file found for " + artifact + " --->  " + JarLicense.buildPomUrl(artifact));
            }
          } else {
            didNotWork(lib);
          }
        });
      }
      executor.shutdown();
    }


    System.out.println("Found " + libs.size() + " libraries.\n\n");
    for (Lib lib : notWorking) {
      System.out.println("Not working: " + lib.toString());
    }
    System.out.println("Not Found " + notWorking.size() + " libraries: \n\n");
    LibraryUsageDumper.dumpTopUsage(LIBS_BY_USAGE.iterator(), Path.of("top-100-libs.txt"), 100);

    for (String discarded : DISCARDED_LICENSES) {
      System.out.println("DISCARDED: " + discarded);
    }

  }

  static synchronized void didNotWork(Lib lib) {
    notWorking.add(lib);
  }

  private static List<Lib> getTopLibs() {
    ObjectMapper mapper = new ObjectMapper();
    try (InputStream is = JacksonJsonParser.class.getClassLoader().getResourceAsStream("top-libs.def.json")) {
      if (is != null) {
        Libs libs = mapper.readValue(is, Libs.class);
        return libs.topLibs();
      }
    } catch (Exception e) {
      System.out.println("Error reading top-libs.def.json: " + e.getMessage());
    }
    return List.of();
  }

  public record LocalArtifact(String groupId, String artifactId, String version, Path localPath) implements Comparable<LocalArtifact> {
    @Override
    public String toString() {
      return groupId + ":" + artifactId + ":" + version;
    }

    @Override
    public int compareTo(LocalArtifact o) {
      return VersionNumberComparator.getInstance().compare(toString(), o.toString());
    }
  }

  private static boolean downloadArtifact(LocalArtifact artifact) {
    if (!Files.exists(artifact.localPath())) {
//      System.out.println("Downloading " + artifact.localPath());
      String home = System.getProperty("user.home");
      String mvnCommand = System.getProperty("os.name").toLowerCase().contains("win") ? "mvn.cmd" : "mvn";
      try {
        int exitCode = new ProcessBuilder(
          Path.of(MAVEN_HOME)
            .resolve("bin")
            .resolve(mvnCommand)
            .toString(),
          "dependency:get",
          "--quiet",
          "-Dartifact=" + artifact,
          "-Dtransitive=false")
          .inheritIO()
          .directory(new File(home, ".m2"))
          .start().waitFor();
        if (exitCode != 0) {
//          System.err.println("ERROR, download failed. Exit code: " + exitCode);
          return false;
        }
      } catch (IOException | InterruptedException e) {
//        System.err.println("Unexpected error!!");
        return false;
      }

    } else {
//      System.out.println("Artifact already exists: " + artifact.localPath());
    }
    return true;
  }

  public static void assertNotEmpty(String value, String messageIfEmpty) {
    if (value == null || value.isEmpty()) {
      System.err.println("ERROR: " + messageIfEmpty);
      System.exit(1);
    }
  }

  private static Path toLocalJarPath(String groupId, String artifactId, String version) {
    return Path.of(System.getProperty("user.home"))
      .resolve(".m2")
      .resolve("repository")
      .resolve(groupId.replace('.', File.separatorChar))
      .resolve(artifactId)
      .resolve(version)
      .resolve(artifactId + "-" + version + ".jar");
  }

}
